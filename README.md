message_distribution 
===


这是个消息转发存储的算法，当一条消息需要转发给很多不同的人时，转发所需要的存储空
间随着人数增加而增加，例如大的群组，微博的转发等，当然有些推拉结合的方式来解决一
些问题，但在此处实现了一种转发的压缩算法，纯粹推，相当简洁，<br><br>
    这个算法分两个部分，第一部分是，实际信息流的排列。到达单个服务器的信息按时间先
后顺序赋予一个单调递增的id（不考虑信息的转发）。这个容易理解，就是后到的信息id越大，
且id不会重复，id为64bit。<br><br>
    第二部分是信息如何转发到每个人，考虑服务器有这样一个序列id1,id2,id3,...,id1000。
然后任何人能收到的序列是这个序列的一个子集。考虑person1收到这样一个消息序列id1,id2,
id50,id1000.如果直接存储需要4×64=256bit，这是个稀疏序列，新的编码方式是，首先存储起
始id，就是id1,然后存储第一个连续id的长度是2,然后存储间隔长度47,然后依次往下，是这个
样子:id1,2,47,1,949,1.需要64+2+6+1+10+1=84(没包含一些附加控制位，但也不会增加多少)，
可以看到主要的比特都是起始id占用的，如果序列更长的话压缩率会更高。其实可以观察到编码
消息的bit与(ln(间隔长度)/ln(2))成正比，因为长度是二进制编码power(2,bit数)=间隔长度。
也就是说消息的传播范围越广消耗的bit数越少。因为是与间隔长度的log成正比，所以就算很稀疏开销
也会增加很慢，远小于64bit。

